---
title: '入门浅记HTTP缓存机制'
date: '2018-08-14 22:07:56'
tag: 'HTTP'
path: 'http-caching-mechanism'
---

## HTTP简述

前端关于网络协议的入门，接触得最多最主要的就是HTTP协议。浏览器与服务器之间的通信协议，从浏览器发出请求，由服务器响应请求。图解如下：

![HTTP图解](https://www.coyeah.top/source/http-model.png)

HTTP报文是浏览器与服务器之间通信的载体（数据块），由报文首部（附加信息，如cookie、缓存信息等）和报文主体（传输的数据内容）构成。

请求报文：`浏览器 => 服务器`；报文首部构成：请求行（HTTP方法、URI、HTTP版本）、请求首部字段、其他。

响应报文：`服务器 => 浏览器`；报文首部构成：状态行（HTTP版本、状态码）、响应首部字段、其他。

## HTTP缓存机制

### 强缓存 & 协商缓存

强缓存：在缓存数据未失效时，直接使用缓存数据，不向服务器发送请求。

协商缓存：需要向服务器发送请求，附上缓存信息，让服务器判断是否需要更新缓存数据。

强缓存优先级高于协商缓存。

### 强缓存

强缓存分为两种：Expires & Cache-Control

#### Expires

服务器告诉浏览器缓存数据的过期时间（GMT，格林尼治时间）。当浏览器判断时间没有超过Expires设置的过期时间时，则继续使用当前的缓存数据。衍生出来的问题就是，当浏览器时间和服务器时间不同步的时候，缓存机制失效。由于Expires是HTTP1.0的东西，而现在的浏览器默认的HTTP版本为1.1，所以它的作用基本被忽略了。

#### Cache-Control

服务器告诉浏览器一个过期的相对时间，浏览器通过接收响应的时间和这个相对时间进行计算，来判断是否读取本地的缓存数据。这样就解决了Expires中的时间不同步问题。

### 协商缓存

强缓存的问题在于它的强制性，时间未到，就不会向服务器发送请求。这样一刀切的方式会导致数据更新不及时的问题和数据无变化导致的网络资源浪费。

因此通过协商缓存来规避这样的问题，节省服务器资源。图解如下：

![协商缓存图解](https://www.coyeah.top/source/http-cache.jpg)

协商缓存通过两组报文首部字段结合使用：

* Last-Modified & If-Modified-Since
* ETag & If-None-Match

#### Last-Modified & If-Modified-Since

浏览器和服务器进行协商，着重点在文件的最近修改时间。请求过程：

* 浏览器请求静态资源index.js
* 服务器读取磁盘文件index.js，响应浏览器请求，附上首部字段`Last-Modified`，值为该文件的最近修改时间。
* 在浏览器的缓存文件过期时，浏览器请求服务器，附上首部字段`If-Modified-Since`，值为该文件的最近修改时间（同响应的Last-Modified）。
* 服务器判断If-Modified-Since的值与文件最近修改时间是否一致，是则返回304状态码，表示继续使用本地缓存数据；否则返回200状态码，返回对应文件并附上文件最近修改时间。

问题：

* 由于Last-Modified修改时间是GMT时间，只能精确到秒，如果文件在一秒内多次改动，服务器则无法判断，浏览器也获取不到最新的资源。
* 如果服务器上的文件被多次改动但是内容却没有发生变化，服务器依旧需要响应请求，浪费网络资源。

#### ETag & If-None-Match

为了解决时间不精确的问题，浏览器和服务器再次协商，而这次着重于唯一标识符ETag。请求过程：

* 浏览器请求静态资源index.js
* 服务器读取磁盘文件index.js，响应浏览器请求，附上首部字段`ETag`，值为该文件的唯一标识符。
* 当浏览器的缓存文件过期时，浏览器请求服务器，附上首部字段`If-None-Match`，值为该文件的唯一标识符（同响应的ETag）。
* 服务器判断If-None-Match的值与文件的ETag是否一致，是则返回304状态码，表示继续使用本地缓存数据；否则返回200状态码，返回对应文件并附上文件唯一标识符。


参考资料：

* [前端也要懂Http缓存机制](https://juejin.im/post/5b70edd4f265da27df0938bc)