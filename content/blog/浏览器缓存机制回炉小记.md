---
title: '浏览器缓存机制回炉小记'
date: '2020-08-15 11:00:56'
tag: 'HTTP'
path: 'browser-caching-mechanism'
---

## HTTP简述

前端关于网络协议的入门，接触得最多最主要的就是HTTP协议。浏览器与服务器之间的通信协议，从浏览器发出请求，由服务器响应请求。图解如下：

![HTTP图解](https://www.coyeah.top/source/http-model.png)

HTTP报文是浏览器与服务器之间通信的载体（数据块），由报文首部（附加信息，如cookie、缓存信息等）和报文主体（传输的数据内容）构成。

请求报文：`浏览器 => 服务器`；报文首部构成：请求行（HTTP方法、URI、HTTP版本）、请求首部字段、其他；

响应报文：`服务器 => 浏览器`；报文首部构成：状态行（HTTP版本、状态码）、响应首部字段、其他；

## 浏览器缓存位置

### memory cache

资源缓存在浏览器内存中，内存大小受限，后打开的 Tab 会释放前 Tab 的内存；仅作用于当前 Tab，关闭即刻释放；优先级高于 disk cache；**内存缓存的控制权在浏览器，前后端都不能干涉**。

### disk cache

缓存在硬盘（实际的文件系统）当中，持久缓存；受上限影响会清除；因为涉及文件的 IO 操作，会比 memory cache 慢；严格遵守http响应头字段来判断哪些资源是否要被缓存，哪些资源是否已经过期；**硬盘缓存的控制权在后端**。

### service worker

本质是作为服务器与客户端之间的代理服务器，伴随着PWA出现。**Service Worker 真正意义上将缓存控制权交给了前端**，相比于LocalStorage、SessionStorage，后两者只是单纯的接口数据缓存，例如用户信息（一个对象）、列表信息（一个数组），而前者可以缓存静态资源，甚至拦截网络请求，根据网络状况作出不同的缓存策略。

## 缓存策略

### 强缓存

在缓存数据未失效时，直接使用缓存数据，不向服务器发送请求。强缓存分为两种：Expires & Cache-Control。

#### Expires

服务器告诉浏览器缓存数据的过期时间（GMT，格林尼治时间）。当浏览器判断时间没有超过Expires设置的过期时间时，则继续使用当前的缓存数据。衍生出来的问题就是，当浏览器时间和服务器时间不同步的时候，缓存机制失效。由于Expires是HTTP1.0的东西，而现在的浏览器默认的HTTP版本为1.1，所以它的作用基本被忽略了。

#### Cache-Control

服务器告诉浏览器一个过期的相对时间 `max-age=${time}`，浏览器通过接收响应的时间和这个相对时间进行计算，来判断是否读取本地的缓存数据。这样就解决了Expires中的时间不同步问题，优先级高于expires的绝对时间。

Cache-Control 的主要属性，可组合使用：

+ public：允许代理服务器和浏览器缓存；
+ private：仅允许浏览器缓存；
+ no-cache：绕过浏览器，直接请求服务器是否使用缓存（浏览器自身依然缓存）；
+ no-stroe：浏览器和服务器都不可以缓存；

### 协商缓存

强缓存的问题在于它的强制性，时间未到，就不会向服务器发送请求。这样一刀切的方式会导致数据更新不及时的问题和数据无变化导致的网络资源浪费。

因此通过协商缓存来规避这样的问题，节省服务器资源。图解如下：

![协商缓存图解](https://www.coyeah.top/source/http-cache.jpg)

协商缓存通过两组报文首部字段结合使用：

+ Last-Modified & If-Modified-Since
+ ETag & If-None-Match

#### Last-Modified & If-Modified-Since

浏览器和服务器进行协商，着重点在文件的最近修改时间。请求过程：

+ 浏览器请求静态资源index.js
+ 服务器读取磁盘文件index.js，响应浏览器请求，附上首部字段`Last-Modified`，值为该文件的最近修改时间。
+ 在浏览器的缓存文件过期时，浏览器请求服务器，附上首部字段`If-Modified-Since`，值为该文件的最近修改时间（同响应的Last-Modified）。
+ 服务器判断If-Modified-Since的值与文件最近修改时间是否一致，是则返回304状态码，表示继续使用本地缓存数据；否则返回200状态码，返回对应文件并附上文件最近修改时间。

问题：

+ 由于Last-Modified修改时间是GMT时间，只能精确到秒，如果文件在一秒内多次改动，服务器则无法判断，浏览器也获取不到最新的资源。
+ 如果服务器上的文件被多次改动但是内容却没有发生变化，服务器依旧需要3响应请求，浪费网络资源。

#### ETag & If-None-Match

为了解决时间不精确的问题，浏览器和服务器再次协商，而这次着重于唯一标识符ETag。请求过程：

+ 浏览器请求静态资源index.js
+ 服务器读取磁盘文件index.js，响应浏览器请求，附上首部字段`ETag`，值为该文件的唯一标识符。
+ 当浏览器的缓存文件过期时，浏览器请求服务器，附上首部字段`If-None-Match`，值为该文件的唯一标识符（同响应的ETag）。
+ 服务器判断If-None-Match的值与文件的ETag是否一致，是则返回304状态码，表示继续使用本地缓存数据；否则返回200状态码，返回对应文件并附上文件唯一标识符。

### 启发式缓存

当既没有设置 max-age 相对时间，也没有设置 exprires 绝对时间的时候，浏览器依然会请求缓存的内容，而不是请求服务器走。

启发式缓存策略，它的计算方式为根据响应头中2个时间字段 Date 和 Last-Modified 之间的时间差值，取其值的`10%`作为缓存时间周期。

![浏览器从请求到显示页面的缓存图解](https://www.coyeah.top/source/http-cache-flow.jpg)

## 常见的用户行为

当cache control不是设置为no-store的时候：

1、打开新窗口：如果命中了强缓存，则请求 disk cache；否则请求服务器；

2、刷新：如果存在缓存，优先命中 memory cache，其次是 disk cache；否则请求服务器；

3、强制刷新：请求服务器获取最新资源；

4、地址栏输入：同刷新
