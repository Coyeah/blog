| 题目         | 创建时间            | 标签      |
| ------------ | ------------------- | --------- |
| 记第一次面试 | 2018-04-11 21:28:15 | 面试/前端 |

-----

> 记第一次大厂面对面面试。

提前两天就接到面试通知了，得跑到广州一大酒店里面试。面对面好就好在能提前准备准备。第一次大厂的面试，确实感觉有点紧张。

上来介绍完，被问了点专业课程的内容以及成绩。

再来就是实习里做的项目。好是好在实习的时候完全独立学习和开发，所以印象比较深刻，回答起来也不会磕巴和紧张，心里也松了一下。讲述了自己在实习期间学习的过程，也算是我步入前端的过程。

问起我学习JavaScript的路径，再者就是前端框架用了哪些。学过一点点React，幸好他也没有多问我关于React的东西，知道点知识点，怕是一紧张答不上来了。

前面五六分钟的铺垫，终于要问点技术上的东西了。

## 闭包

引用[Ahonn](https://github.com/ahonn)师兄的解释。

> 就是 A 函数返回 B 函数，B 函数能够访问 A 函数中的局部变量，使得在 A 外部的作用域中能够使用 B 函数间接操作 A 函数中的局部变量，这样就形成了一个闭包。A 函数中的局部变量与返回的 B 函数一同存在，不会被垃圾回收机制清理（引用还存在）。

闭包的问题几乎在前端面试都会提及到。要了解闭包，首先要理解JavaScript特使的变量作用域。JavaScript在函数内部可以直接读取全部变量，而在函数外部无法读取函数内部的局部变量。

作用域的知识点，在[『你不知道的JavaScript』](https://book.douban.com/subject/26351021/)第一部分详细介绍了。恰恰早一个星期买了这本书来阅读了。

闭包的优点：

* 实现封装，防止变量跑到外层作用域中，发生命名冲突。
* 数据缓存。
* 面对对象中的对象。
* 匿名自执行函数，匿名自执行函数可以减小内存消耗

闭包的缺点：

* 内存消耗，内存容易被挤爆，不会被垃圾回收机制清理。
* 使用闭包时，会涉及到跨作用域访问，每次访问都会导致性能损失。

```JavaScript
function f1(){
  var n = HelloWorld;
  function f2(){
    alert(n); // HelloWorld
  }
}
```

## 函数自执行

手写函数自执行。自执行函数，即定义和调用合为一体。

```JavaScript
// one
var demo = function () {  // 函数表达式
  // TODO
}

// two
(function () {
  // TODO
})();
```

面试官看完后还提出了setTimeout()。

```JavaScript
setTimeout(function(){ // TODO }, 1000);
```

定义函数的方式有两种：函数声明和函数表达式。不同的是，JS在进行预解析时函数声明会提升，而函数表达式必须JS顺序直行道此函数代码时才逐行解析。

## call()和apply()

每个函数都包含这两个非继承的方法两个，作用是一样的。

都是在特定的作用域中调用函数，等于设置函数体内this对象的值，以扩充函数赖以运行的作用域。call()和apply()为了改变某个函数运行时的context（即上下文）而存在的。

* call()使用示例：

```JavaScript
// demo1
window.number = 'one';
document.number = 'two';
var tmp = { number: 'three' };
function check() {
  console.log(this.number);
}
check.call();			// one (默认传参)
check.call(window);		// one
check.call(document);	// two
check.call(this);		// one
check.call(tmp);		// three

// demo2
var Pet = {
  words : '...',
  speak : function (say) {
    console.log(Speak + '' + this.words);
  }
}
Pet.speak('something');			// Speak...
var Dog = {
	words: 'wowo'
}
Pet.speak.call(Dog, 'Speak');	// Speakwowo
```

* apply()使用示例：

```JavaScript
// demo1
window.number = 'one';
document.number = 'two';
var tmp = { number: 'three' };
function check() {
  console.log(this.number);
}
check.apply();			// one (默认传参)
check.apply(window);	// one
check.apply(document);	// two
check.apply(this);		// one
check.apply(tmp);		// three

// demo2
function Pet(words) {
  this.words = words;
  this speak = function() {
    console.log(this.words);
  }
}
function Dog(words) {
  Pet.apply(this, arguments);
}
var dog = new Dog('wowo');
dog.speak();
```

两者不同点是接收参数的方式不同。

* apply()方法 接收两个参数，一个是函数运行的作用域（this），另一个是参数数组。
* call()方法 第一个参数和apply()方法的一样，但是传递给函数的参数必须列举出来。

用途：

* 类的继承
* 指针指向的变更

## cookie和session的区别

*cookie*是客户端保存用户信息的一种机制，用来记录用户一些信息，也是实现session的一种方式。

*session*是在服务端保存的一种数据结构，用于跟踪用户转台，这个数据可以保存在集群、数据库、文件中。

## 客户端访问session数据如何获取

这一块的知识点还真答不上来，一开始把AJAX答了上去。面试官也稍稍解释了一下问题，具体流程原理，如何在客户端访问具体的session数据。

在cookie中会有个sessionID，客户端在获取session的时候同时获取了sessionID，通过其匹配客户端和服务器端的session，避免对应不上的问题。

## 常见前端攻击方式及防范措施

### XSS

> 跨站脚本攻击，攻击者往Web页面插入恶意Script代码，当用户浏览该页时，其中的Script代码会被执行，从而达到恶意攻击用户的目的。

*防御措施：*

* 对所有用户提交内容进行可靠的输入验证，包括URL、查询关键字、HTTP头、POST数据等，仅接受指定长度范围内、采用适当格式、采用所预期的字符的内容提交，对其他一律过滤。
* 实现session标记、CAPTCHA系统或者HTTP引用投检查，以防功能被第三方网站所执行。
* 确认接收的内容被妥善的规范化，仅包括最小的、安全的Tag（没有JavaScript），去掉热河对远程内容的应用，试用贴HTTP only的cookie。
* 使用HTTPS

### CSRF

> 站点请求伪造通过在访问用户被认为已经通过身份验证的Web应用程序的页面中包含恶意代码或者链接来工作。如果该Web应用程序的会话没有超时，攻击者可能执行未授权的命令。

*防范措施：*

* 验证HTTP Referer字段
* 在请求地址中添加token并验证
* 在HTTP投中自定义属性并验证
* 正确使用GET，POST和Cookie
* 在非GET请求中添加伪随机数

### SQL注入

> 用户可以提交一段数据库查询代码，根据程序返回的结果，获得某些想得知的数据

*防范措施：*

* 采用SQL语句预编译和绑定变量。采用JDBC的预编译语句集，内置处理SQL注入的能力。
* 使用正则表达式来过滤一些SQL关键字，如OR、WHERE等。

### cookie窃取和session劫持

> cookie包含了浏览器客户端的用户凭证，session在服务器端用于维护相对较大的用户信息。cookie窃取和session劫持会导致攻击者合法登录用户账户，可以浏览大部分用户资源。

### 钓鱼攻击（重定向攻击）

> 攻击者会发送受害者一个合法链接，当链接被点击时，用户被导向一个似是而非的非法网站，从而达到骗取用户信息，窃取用户资料的目的。

*防范措施：*

* 对所有的重定向操作进行审核,以避免重定向到一个危险的地方。

## HTTP头部信息

* **Accept:** 浏览器能够处理的内容类型；
* **Accept-Charset:** 浏览器能够显示的字符集；
* **Accept-Encoding:** 浏览器能够处理的压缩编码；
* **Accept-Language:** 浏览器当前设置的语言；
* **Connection:** 浏览器与服务器之间的连接类型；
* **Cookie:** 当前页面设置的任何Cookie；
* **Host:** 发出请求的页面所在的域；
* **Referer:** 发出请求的页面的URL；
* **User-Agent:** 浏览器的用户代理字符串；

## 响应式开发

* 网格布局
* flex布局
* 媒体查询

## 对象API

平时用惯了SublimeText，外加对英语极度不明感，拼写错误真的心疼自己。最最重要的是，让我写String和Array的，先写个String的吧，结果我全写了Array，会不会大扣分呢？

### Array对象API

* **concat()** : 结合多个数组，并返回结果。
* **join()** : 把数组所有元素放入一个字符串，元素通过指定分隔符进行分隔
* **pop()** : 删除并返回数组最后一个元素
* **push()** : 向数组末尾添加一个或更多元素，并返回新的长度
* **reverse()** : 点到数组中元素顺序
* **shift()** : 删除并返回数组的第一个元素
* **slice()** : 从某个已有的数组返回选定的元素
* **sort()** : 对数组元素进行排序
* **splice()** : 删除元素并向数组添加新元素
* **valueOf()** : 返回数组对象的原始值

## 算法

### 快速排序

```JavaScript
var arr = [12,20,5,16,15,1,30,45,23,9];
quickSort(arr, 0, arr.length - 1);
console.log(arr);   // 1,5,9,12,15,16,20,23,30,45

function quickSort(arr, low, high) {
  var start = low;
  var end = high;
  var key = arr[low];

  while (end > start) {
    // 从后往前比较
    while (end > start && arr[end] >= key) {
      end--;
    }
    if (arr[end] <= key) {
      var tmp = arr[end];
      arr[end] = arr[start];
      arr[start] = tmp;
    }
    // 从前往后比较
    while (end > start && arr[start] <= key) {
      start++;
    }
    if (arr[start] >= key) {
      var tmp = arr[start];
      arr[start] = arr[end];
      arr[end] = tmp;
    }
  }
  // 此时第一次循环比较结束，关键值的位置已经确定了。左边的值都比关键值小，右边的值都比关键值大，但是两边的顺序还有可能是不一样的，进行下面的递归调用
  if (start > low) {
    quickSort(arr, low, start - 1);
  }
  if (end < high) {
    quickSort(arr, end + 1, high);
  }
}
```

### 两数组合并，去除相同元素

```JavaScript
var arr1 = [1,2,3,4,5,6,7,8,9];
var arr2 = [1,3,4,6,8,9];
var tmp = arr2.join(",");

for (var i = 0; i < arr1.length; i++) {
  for (var j = 0; j < arr2.length; j++) {
    if (arr1[i] != arr2[j] && j == arr2.length - 1) {
      tmp = tmp + "," + arr1[i];
    } else if (arr1[i] == arr2[j]) {
      break;
    }
  }
}
console.log(tmp.split()); // 1,3,4,6,8,9,2,5,7
```

自己写的很简单很原始，面试官表示用ES6一句话的事。

```JavaScri
console.log(Array.from(new Set(arr1.concat(arr2))));
```

# 小结
40min的面试。回答得一半一半，回答问题的过程中总是有点跑题，不过幸好后面都回来了。可能是紧张过头了，问的问题很基础，针对自身学习路径和实践开发经历问的问题也挺重要的感觉，所以在开发和学习的过程中还是得多记录多留意。第一次面试也算是这样了，总结一下继续学习！