| 题目             | 创建时间            | 标签            |
| ---------------- | ------------------- | --------------- |
| 小白实例面向对象 | 2018-05-08 14:37:15 | JavaScript/前端 |

------

好吧，又被一道题难倒了。提问！用面向对象来完成业务DOM操作。怎么做？

面向对象我倒是懂，就是将方法属性都封装在一个对象当中，便于重复使用。在JavaScript上的面向对象也是依托于prototype。

可是落实到实际开发就看傻了眼。

题目：

```HTML
<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
  <title>面向对象 - 业务处理</title>
</head>
<body>
<style>
#business ul {
  display: block;
  list-style: none;
  width: 1000px;
}
.headline,
.num,
.name,
.score,
.age,
.del {
  padding: 5px 0;
  width: 200px;
  float: left;
  text-align: center;
}
.del {
  cursor: pointer;
}
.del:hover {
  color: #fff;
  background-color: red;  
}
</style>
<div id="business">
  <ul>
    <li><div class="headline">序号</div><div class="headline">姓名</div><div class="headline">评分</div><div class="headline">年龄</div><div class="headline">操作</div></li>
  </ul>
  <ul id="list">
    <li><div class="num">1</div><div class="name">张三</div><div class="score">3.7</div><div class="age">23</div><div class="del">删除</div></li>
    <li><div class="num">2</div><div class="name">李四</div><div class="score">2,6</div><div class="age">21</div><div class="del">删除</div></li>
    <li><div class="num">3</div><div class="name">王五</div><div class="score">3.9</div><div class="age">19</div><div class="del">删除</div></li>
  </ul>
</div>
</body>
</html>
```

> 用面向对象的方式和原生JS来完成业务。点击删除，删除该行的用户信息。

一开始，自开屏蔽模式，屏蔽了面向对象四个大字。写下了“答案”。

过程式的编程思想来实现：

```JavaScript
window.onload = function() {
  let listArr = document.getElementById('list').getElementsByTagName('li');

  for (let i = 0; i < listArr.length; i++) {
    listArr[i].getElementsByTagName('div')[4].onclick = function () {
      this.parentNode.remove();
    }
  }
}
```

一步步向面向对象思想的代码方式改进。首先要减少函数的嵌套。变量可以变成全局变量，实现一个init()和change()的函数。

```JavaScript
window.onload = function() {
  listArr = document.getElementById('list').getElementsByTagName('li');

  init();
}

function init() {
  for (let i = 0; i < listArr.length; i++) {
    listArr[i].getElementsByTagName('div')[4].onclick = change;
  }
}

function change() {
  this.parentNode.remove();
}
```

继续继续，创建构造函数，添加属性和方法。这才是面向对象第一步。

```JavaScript
window.onload = function() {
  var myBusiness = new DelRow();
  myBusiness.init();
}

function DelRow() {
  listArr = document.getElementById('list').getElementsByTagName('li');
}

DelRow.prototype.init = function () {
  for (let i = 0; i < listArr.length; i++) {
    listArr[i].getElementsByTagName('div')[4].onclick = change;
  }
}

DelRow.prototype.change = function () {
  this.parentNode.remove();
}
```

这样是会报错有问题的。因为缺少了this。

```JavaScript
window.onload = function() {
  var myBusiness = new DelRow();
  myBusiness.init();
}

function DelRow() {
  this.listArr = document.getElementById('list').getElementsByTagName('li');
}

DelRow.prototype.init = function () {
  for (let i = 0; i < this.listArr.length; i++) {
    this.listArr[i].getElementsByTagName('div')[4].onclick = change();
  }
}

DelRow.prototype.change = function () {
  this.parentNode.remove();
}
```

这样还是会有问题的。这一次是this指向的问题。

一步步分析看看。首先是构造函数中的this，因为是用new来实例化，所以this指向myBusiness；再来init()方法，由myBusiness调用，myBusiness.init()，this指向依旧是myBusiness；问题肯定是出在change()上了，这个this的指向就让人困惑了，它是直接指向DelRow，却又没找着一个名叫parentNode的家伙，因此我们要改变this的指向。

```JavaScript
window.onload = function() {
  var myBusiness = new DelRow();
  myBusiness.init();
}

function DelRow() {
  this.listArr = document.getElementById('list').getElementsByTagName('li');
}

DelRow.prototype.init = function () {
  let that = this;
  for (let i = 0; i < this.listArr.length; i++) {
    this.listArr[i].getElementsByTagName('div')[4].onclick = function() {
      that.change(this);
    }
  }
}

DelRow.prototype.change = function (that) {
  that.parentNode.remove();
}
```

关键就在`let that = this`

that的指向是在DelRow这个构造函数上，方法和函数都基于它。而在调用change(this)中的this，指向的是`this.listArr[i].getElementsByTagName('div')[4]`，因此需要把它传递下去，一边去进行DOM的操作。

**[大功告成]**